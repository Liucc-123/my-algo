列表（list）是一个抽象的数据结构概念，表示元素的有序集合，支持元素的访问、修改、添加、删除和遍历等操作，使用者不需要考虑容量限制的问题。列表可以基于数组或者链表实现。

* 链表天然可以看作是一个列表，其支持元素的增删改查操作，并且可以灵活动态地扩容
* 数组也支持增删改查等操作，但由于数组的长度不可变的特性，当数组达到容量限制时，需要创建一个容量更大的新数组，再将旧数组中的元素复制到新数组中

当使用数组实现列表时，**长度不可变的性质会导致列表的实用性降低**。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。

为解决此问题，我们可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。

实际上，**许多编程语言中的标准库提供的列表是基于动态数组实现的**，例如 Python 中的 `list` 、Java 中的 `ArrayList` 、C++ 中的 `vector` 和 C# 中的 `List` 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。

# 1、列表常用操作

## 1.1、初始化列表

我们通常使用“无初始值”和“有初始值”这两种初始化方法：

```python
# 初始化列表
# 无初始值
nums1: list[int] = []
# 有初始值
nums: list[int] = [1, 3, 2, 5, 4]
```

## 1.2、访问元素

列表本质上是数组，因此可以在 时间内访问和更新元素，效率很高。

```python
# 访问元素
num: int = nums[1]  # 访问索引 1 处的元素

# 更新元素
nums[1] = 0    # 将索引 1 处的元素更新为 0
```

## 1.3、插入与删除元素

相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 ，但插入和删除元素的效率仍与数组相同，时间复杂度为 。

```python
# 清空列表
nums.clear()

# 在尾部添加元素
nums.append(1)
nums.append(3)
nums.append(2)
nums.append(5)
nums.append(4)

# 在中间插入元素
nums.insert(3, 6)  # 在索引 3 处插入数字 6

# 删除元素
nums.pop(3)        # 删除索引 3 处的元素
```

## 1.4、遍历列表

与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。

```python
# 通过索引遍历列表
count = 0
for i in range(len(nums)):
    count += nums[i]

# 直接遍历列表元素
for num in nums:
    count += num
```

## 1.5、拼接列表

给定一个新列表 `nums1` ，我们可以将其拼接到原列表的尾部。

```python
# 拼接两个列表
nums1: list[int] = [6, 8, 7, 10, 9]
nums += nums1  # 将列表 nums1 拼接到 nums 之后
```

## 1.6、排序列表

完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法。

```python
# 排序列表
nums.sort()  # 排序后，列表元素从小到大排列
```

# 2、自定义实现一个列表

大多数编程语言都内置了列表，比如Python的list、Java的ArrayList、C的Vector等，官方编程语言对于列表的设计相对比较复杂精妙，对于初始容量、扩容倍数、扩容触发机制等都是有讲究的，想具体了解的同学可以自己看看源码，比如JDK的源码。

我们这里为了加深对列表特性的了解，自定义实现一个列表功能，包括有：列表初始化、元素追加、插入、更新、删除、查找及扩容等操作。具体代码如下：

```python
"""
自定义实现列表，着重关注以下三个重点：
1、初始容量：选取一个合适的数组初始容量，在这个案例中，我们选取10作为初始容量
2、容量记录：定义一个变量size，用于记录当前列表中元素的个数。当发生元素变更（添加或删除）时，size进行实时变更
3、扩容机制：如果当前列表的容量已满，则需要扩容；先根据扩容倍数创建一个更大的数组，再将之前数据里的元素复制到新数组中。
在这个案例中，我们定义扩容倍数为2
"""
class MyList:
    def __init__(self):
        self._capacity: int = 10  # 列表初始容量是10
        self._arr: list[int] = [0] * self._capacity  # 数组（真正存储元素的容器）
        self._size: int = 0  # 列表长度（当前数组内元素个数）
        self._extend_ratio = 2  # 扩容倍数

    def capacity(self) -> int:
        """获取列表容量"""
        return self._capacity

    def size(self):
        """当前列表的长度"""
        return self._size

    def append(self, num: int):
        """链表末尾添加新元素"""
        # 是否需要扩容
        if self.size() == self.capacity():
            self.extend_capacity()
        self._arr[self.size()] = num
        # 更新数组长度
        self._size += 1

    def insert(self, index: int, num: int):
        """在列表指定位置添加元素"""
        # 检查索引越界
        if index < 0 or index >= self.size():
            raise IndexError("数组越界异常")
        if self.size() == self.capacity():
            self.extend_capacity()
        # 将插入位置及其之后的元素全部后移一位 1, 3, 2, 5, 4, 9, 7 0
        for j in range(self.size(), index, -1):
            self._arr[j] = self._arr[j - 1]
        # 插入元素
        self._arr[index] = num
        # 更新数组长度
        self._size = len(self._arr)

    def remove(self, index: int) -> int:
        """删除指定位置的元素"""
        # 检查索引越界
        if index < 0 or index >= self.size():
            raise IndexError("数组越界异常")
        tmp = self._arr[index]
        # 指定索引及之后的元素前移一位 1 [3] 2 5 4
        for j in range(index, self.size() - 1):
            self._arr[j] = self._arr[j + 1]
        # 返回被删除的元素
        return tmp

    def set(self, index: int, num: int):
        """更新指定位置的元素"""
        # 检查索引越界
        if index < 0 or index >= self.size():
            raise IndexError("数组越界异常")
        self._arr[index] = num
        pass

    def get(self, index: int):
        """获取指定位置的元素"""
        # 检查索引越界
        if index < 0 or index >= self.size():
            raise IndexError("数组越界异常")
        return self._arr[index]

    def to_array(self) -> list[int]:
        """返回有效长度的列表"""
        return self._arr[:self.size()]

    def extend_capacity(self):
        """列表扩容"""
        # 新建一个数组，容量是当前容量的两倍，将原数组的元素复制到新数组中
        self._arr = self._arr + [0] * (self._extend_ratio - 1) * self.capacity()
        # 更新列表容量
        self._capacity = len(self._arr)


if __name__ == '__main__':
    my_list = MyList()
    my_list.append(1)
    my_list.append(3)
    my_list.append(2)
    my_list.append(5)
    my_list.append(4)
    print(f"初始列表：{my_list.to_array()}")
    my_list.append(9)
    my_list.append(7)
    print(f"追加元素后的列表：{my_list.to_array()}")
    print(f"获取列表最后一个元素：{my_list.get(my_list.size() - 1)}")
    num = 10
    my_list.insert(2, num)
    print(f"向索引为2的位置插入元素{num}后的列表：{my_list.to_array()}")
    rem_num = my_list.remove(4)
    print(f"删除索引为4位置的元素，被删除的元素是：{rem_num}，删除后的列表：{my_list.to_array()}")
    my_list.set(3, 100)
    print(f"更新后的列表：{my_list.to_array()}")
```

运行结果如下：

```sh
初始列表：[1, 3, 2, 5, 4]
追加元素后的列表：[1, 3, 2, 5, 4, 9, 7]
获取列表最后一个元素：7
向索引为2的位置插入元素10后的列表：[1, 3, 10, 2, 5, 4, 9, 7, 0, 0]
删除索引为4位置的元素，被删除的元素是：5，删除后的列表：[1, 3, 10, 2, 4, 9, 7, 0, 0, 0]
更新后的列表：[1, 3, 10, 100, 4, 9, 7, 0, 0, 0]
```

